#Processes and signals
	
A PID (i.e., process identification number) is an identification number that is automatically assigned to each process
The default maximum value of PIDs is 32,767. 
The file pid_max, which was introduced with the Linux 2.5 kernel, specifies the value at which PIDs wrap around
(i.e., the value in this file is one greater than the maximum PID). 
The PIDs for the processes currently on the system can be found by using the ps command or the pstree command (which shows the process names and PIDs in a tree diagram). The top command also shows the PIDs of currently running processes along with other information about them, but it differs in that it continuously updates the information. The pidof command provides the PID of a program whose name is passed to it as an argument (i.e., input).
the kill command. This command makes it possible to end a program that cannot otherwise be stopped except by rebooting (i.e., restarting) the system, and it is thus an important element in the stability and robustness of Unix-like operating systems.
Information on current processes is stored in the /proc filesystem. This filesystem consists of kernel data that changes in real time 
It is easy to extract the information contained therein using commands such as cat.

ls /proc | less

 /proc with the ls command as follows will show numerous directories whose names consist only of numbers:
It is convenient to pipe (i.e., transfer) the output from ls /proc to the less command because such output can be fairly long and less allows it to be read one screenful at a time.

the file cmdline contains the name of the command (along with any options and arguments) that the process was started with, and it can be easily read with the cat or head command. For instance, the cmdline file for PID 1 can be read as follows:

cat /proc/1/cmdline


#linux process
/****
Linux Processes – Environment extern, environ, getenv, setenv
***/

the practical aspects of process environment, process control, process relationships etc.

Linux Processes Series: part 1
what is a process - A process can be thought of as an instance of a program in execution.
The main() Function

A ‘C’ program always starts with a call to main() function. This is the first function that gets called when a program is run.
The prototype of a main() function is :

int main(int argc, char *argv[]);

example code

#include<stdio.h>

int main(int argc, char *argv[])
{
  int count = argc;
  printf("\n The number of arguments passed is [%d] \n", count);

  int c = 0;
  while(c < count)
  {
    printf("\n The argument [%d] is : [%s]\n", c+1, argv[c]);
    c++;
  }
  return 0;
}

output

$ ./main abc 1 3

The number of arguments passed is [4]

The argument [1] is : [./main]

The argument [2] is : [abc]

The argument [3] is : [1]

The argument [4] is : [3]

---Environment List

Type the command ‘env’ on your Linux prompt and you will get a list of name=value pairs.

There are two ways in which we can access a process environment:
1--Through the global variable ‘extern char **extern‘
2--Through the third argument to the main() function ‘char *envp[]’

how to access the environment from within a process :

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

extern char **environ;

int main(int argc, char *argv[])
{
  int count = 0;

  printf("\n");
  while(environ[count] != NULL)
  {
    printf("[%s] :: ", environ[count]);
    count++;
  }

  char *val = getenv("USER");
  printf("\n\nCurrent value of environment variable USER is [%s]\n",val);

  if(setenv("USER","Arora",1))
  {
    printf("\n setenv() failed\n");
    return 1;
  }
 printf("\n Successfully Added a new value to existing environment variable USER\n");

  val = getenv("USER");
  printf("\nNew value of environment variable USER is [%s]\n",val);

  while(1)
  {
    sleep(2);
  }
  return 0;
}

** getenv – Get value of a particular environment variable
** setenv – Set a new value to an environment variable

---output of the above program comes out to be

$ ./environ

[ORBIT_SOCKETDIR=/tmp/orbit-himanshu] :: [SSH_AGENT_PID=1627] :: [TERM=xterm] ::
[SHELL=/bin/bash] :: [WINDOWID=39846040] :: [GTK_MODULES=canberra-gtk-module] ::
[USER=himanshu] :: [SSH_AUTH_SOCK=/tmp/keyring-6kpqGc/ssh] ::
..
..

Current value of environment variable USER is [himanshu]

Successfully Added a new value to existing environment variable USER

New value of environment variable USER is [Arora]

#linux signal

A signal is an event generated by the UNIX and Linux systems in response to some condition.
A signal is just like an interrupt.

There are two types of signals:

1---- Maskable: signals which can be changed or ignored by the user (e.g., Ctrl+C).
2-----Non-Maskable: signals which cannot be changed or ignored by the user. These typically occur when the user is signaled for non-recoverable hardware errors.

Signals List

Signal	Description

SIGHUP -	Hang-up detected on controlling terminal or death of controlling process.
SIGINT	-       Issued if the user sends an interrupt signal (Ctrl + C).
SIGQUIT	-       Issued if the user sends a quit signal (Ctrl + D).
SIGFPE	-       Issued if an illegal mathematical operation is attempted.
SIGKILL	-       If a process gets this signal, it must quit immediately and will not perform any clean-up operations.
SIGTERM	-       Software termination signal (sent kill by default).
SIGALRM	-       Alarm clock signal (used for timers).

#process management in linux

 A process in Linux is nothing but a program in execution.
Types of Processes in Linux

1-- Foreground Processes
depend on the user for input
also referred to as interactive processes

2-- Background Processes
run independently of the user
referred to as non-interactive or automatic processes

Process States in Linux

1** Running - A process in running state means that it is running or it’s ready to run.

2** Sleeping - The process is in a sleeping state when it is waiting for a resource to be available.

   -- Interruptible sleep - A process in Interruptible sleep will wakeup to handle signals
   -- Uninterruptible sleep - whereas a process in Uninterruptible sleep will not.

3** Stopped - A process enters a stopped state when it receives a stop signal.

4** Zombie - Zombie state is when a process is dead but the entry for the process is still present in the table.

Different Commands for Process Management in Linux

1*** 1. The top Command for Mananging Linux Processes - To track the running processes on your machine you can use the top command.
$ top

Let’s understand the output a little better:

PID: Unique Process ID given to each process.
User: Username of the process owner.
PR: Priority given to a process while scheduling.
NI: ‘nice’ value of a process.
VIRT: Amount of virtual memory used by a process.
RES: Amount of physical memory used by a process.
SHR: Amount of memory shared with other processes.
S: state of the process
‘D’ = uninterruptible sleep
‘R’ = running
‘S’ = sleeping
‘T’ = traced or stopped
‘Z’ = zombie
%CPU: Percentage of CPU used by the process.
%MEM; Percentage of RAM used by the process.
TIME+: Total CPU time consumed by the process.
Command: Command used to activate the process.

2*** 2. ps command
-ps command is short for ‘Process Status’. It displays the currently-running processes.

output generated is not in realtime.
$ ps

The terminology is as follows :

PID	process ID
TTY	terminal type
TIME	total time the process has been running
CMD	name of the command that launches the process
%CPU represents the amount of computing power the process is taking.
%MEM represents the amount of memory the process is taking up.
STAT represents process state.

more information using ps command use:
$ ps -u

3*** 3. Stop a process
To stop a process in Linux, use the 'kill’ command. kill command sends a signal to the process.

most common one is ‘kill -9’ which is ‘SIGKILL’.
$ kill -L
The default signal is 15, which is SIGTERM. Which means if you just use the kill command without any number, it sends the SIGTERM signal.
$ kill [pid]
$ kill -9 [pid]

4*** 4. Change priority of a process.

The priority value for a process is called the ‘Niceness’ value. Niceness value can range from -20 to 19. 0 is the default value.

To start a process and give it a nice value other than the default one, use:
$ nice -n [value] [process name]

To change nice value of a process that is already running use:
renice [value] -p 'PID'

